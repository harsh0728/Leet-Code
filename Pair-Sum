/*
 Pair Sum
Problem statement
You are given an integer array 'ARR' of size 'N' and an integer 'S'. Your task is to return the list of all pairs of elements such that each sum of elements of each pair equals 'S'.

Note:

Each pair should be sorted i.e the first value should be less than or equals to the second value. 

Return the list of pairs sorted in non-decreasing order of their first value. In case if two pairs have the same first value, the pair with a smaller second value should come first.
Detailed explanation ( Input/output format, Notes, Images )
Constraints:
1 <= N <= 10^3
-10^5 <= ARR[i] <= 10^5
-2 * 10^5 <= S <= 2 * 10^5

Time Limit: 1 sec
Sample Input 1:
5 5
1 2 3 4 5
Sample Output 1:
1 4
2 3
Explaination For Sample Output 1:
Here, 1 + 4 = 5
      2 + 3 = 5
Hence the output will be, (1,4) , (2,3).
Sample Input 2:
5 0
2 -3 3 3 -2
Sample Output 2:
-3 3
-3 3
-2 2
*/

#include <bits/stdc++.h>
using namespace std;

vector<vector<int>> pairSum(vector<int> &arr, int s) {
    vector<vector<int>> result;
    int n = arr.size();
    
    // Step 1: Sort the array
    sort(arr.begin(), arr.end());
    
    // Step 2: Two pointer approach
    int left = 0;
    int right = n - 1;
    
    while (left < right) {
        int currentSum = arr[left] + arr[right];
        
        if (currentSum == s) {
            // Found a pair
            result.push_back({arr[left], arr[right]});
            
            // CRITICAL: Handle duplicates
            // We need to find all pairs, so if we have duplicates
            // at left or right, we need to count all combinations
            
            int leftVal = arr[left];
            int rightVal = arr[right];
            int leftCount = 0;
            int rightCount = 0;
            
            // Count duplicates at left
            while (left < right && arr[left] == leftVal) {
                leftCount++;
                left++;
            }
            
            // Count duplicates at right
            while (left <= right && arr[right] == rightVal) {
                rightCount++;
                right--;
            }
            
            // If both values are same (e.g., [2, 2] for sum = 4)
            if (leftVal == rightVal) {
                // nC2 combinations = n*(n-1)/2
                int totalCount = leftCount + rightCount;
                int pairs = (totalCount * (totalCount - 1)) / 2;
                
                // We already added one pair, add remaining
                for (int i = 1; i < pairs; i++) {
                    result.push_back({leftVal, rightVal});
                }
            } else {
                // Different values: leftCount * rightCount combinations
                // We already added one, add remaining
                for (int i = 1; i < leftCount * rightCount; i++) {
                    result.push_back({leftVal, rightVal});
                }
            }
            
        } else if (currentSum < s) {
            // Sum too small, need larger number
            left++;
        } else {
            // Sum too large, need smaller number
            right--;
        }
    }
    
    return result;
}


